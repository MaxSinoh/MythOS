//
//                       _oo0oo_
//                      o8888888o
//                      88' . '88
//                      (| -_- |)
//                      0\  =  /0
//                    ___/`---'\___
//                  .' \|     |// '.
//                 / \|||  :  |||// "
//                / _||||| -:- |||||- "
//               |   | \\  -  /// |   |
//               | \_|  ''\---/''  |_/ |
//               \  .-\__  '-'  ___/-. /
//             ___'. .'  /--.--\  `. .'___
//          .''' '<  `.___\_<|>_/___.' >' '''.
//          | | :  `- \`.;`\ _ /`;.`/ - ` : | |
//          \  \ `_.   \_ __\ /__ _/   .-` /  /
//      =====`-.____`.___ \_____/___.-`___.-'=====
//                        `=---='
//
//      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//             ***GOD BLESS   ·   NEVER CRASH***
//
//      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//        COPYRIGHT (C) 2025 MAXSINOH & LUOYUDIAN
//                  ALL RIGHTS RESERVED
//
//      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//                      MYTHOS IDT
//
//      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#include <asm/idt/idt.h>

// 中断门描述符格式宏定义
#define IDT_GATE(num, selector) ((unsigned long)selector << 16 | (unsigned long)(num) << 8 | 0x8E)
// 中断门描述符格式：中断向量号 | 代码段选择子 | 中断类型（0x8E）

// 内核代码段选择子，通常定义为0x08（GDT的第1个条目）
#define KERNEL_CS 0x08

// 初始化中断描述符表
void initIDT(void) {
    unsigned long idt[256]; // 中断门描述符表，大小为256个条目（每个条目8字节）

    for (int i = 0; i < 256; ++i) {
        idt[i] = IDT_GATE(i, KERNEL_CS); // 设置所有中断门的代码段选择子为KERNEL_CS
    }
    // 加载中断描述符表
    __asm__ volatile("lidt (%0)" ::"r"(idt)); // 使用内联汇编将IDT的地址加载到IDTR寄存器中，以便CPU能够访问它。
    // 这里使用了GCC的内联汇编语法。%0是一个占位符，代表第一个输入操作数（这里是idt的地址）。
    // "r"表示这是一个寄存器类型的约束，告诉编译器将这个值放入一个通用寄存器中。
    // "lidt"是加载IDT的指令，它将紧跟其后的内存地址（即idt数组）加载到IDTR寄存器中。
    // ::"r"(idt)这部分是GCC内联汇编的输入部分，它告诉编译器将idt变量的地址放入一个寄存器中。
}
